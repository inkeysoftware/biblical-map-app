const { app, BrowserWindow } = require('electron');
const { initialize, enable } = require('@electron/remote/main');
const { ipcMain, dialog } = require('electron');
const fs = require('fs');
const path = require('path');
const xml2js = require('xml2js');
// const usfm = require('usfm-js');

// Paratext project path initialization
let PARATEXT_PROJECTS_PATH = '';

// Function to initialize and validate Paratext projects path
async function initParatextProjectsPath() {
  try {
    // Check for existing path in localStorage
    const storedPath = getStoredProjectsPath();
    if (storedPath && validateParatextPath(storedPath)) {
      PARATEXT_PROJECTS_PATH = storedPath;
      console.log(`Using stored Paratext projects path: ${PARATEXT_PROJECTS_PATH}`);
      return true;
    }      
    
    // Check default path
    const defaultPath = 'C:\\My Paratext 9 Projects';
    if (fs.existsSync(defaultPath)) {
      // Validate that the path has the required _MapLabelerTemplates folder
      if (validateParatextPath(defaultPath)) {
        PARATEXT_PROJECTS_PATH = defaultPath;
        console.log(`Using default Paratext projects path: ${PARATEXT_PROJECTS_PATH}`);
        saveProjectsPath(defaultPath);
        return true;
      }
    } else {
      console.log(`Default Paratext folder not found: ${defaultPath}`);
    }
    
    // Don't attempt to prompt the user here - we'll handle this in the app.whenReady() section
    // to ensure the window is created first
    console.log('Valid Paratext projects path not found. Dialog will be shown after window creation.');
    return false; // Return false to indicate we need to show a dialog
  } catch (err) {
    console.error('Error initializing Paratext projects path:', err);
    return false;
  }
}

// Function to validate the Paratext projects path
function validateParatextPath(folderPath) {
  try {
    console.log(`Validating Paratext path: "${folderPath}"`);
    
    // Check that the folder exists
    if (!fs.existsSync(folderPath)) {
      console.log(`VALIDATION FAILED: Path does not exist: "${folderPath}"`);
      return false;
    }
      
    // Check for the _MapLabelerTemplates folder
    const mapLabelerTemplatesPath = path.join(folderPath, '_MapLabelerTemplates');
    if (!fs.existsSync(mapLabelerTemplatesPath)) {
      console.log(`VALIDATION FAILED: Required _MapLabelerTemplates folder not found in: "${folderPath}"`);
      console.log('This folder must be installed separately before using this application');
      return false;
    }
    
    // Validation passed
    console.log(`VALIDATION PASSED: "${folderPath}" is a valid Paratext projects path`);
    return true;
  } catch (err) {
    console.error('Error validating Paratext path:', err);
    return false;
  }
}

// Function to get the stored Paratext projects path
function getStoredProjectsPath() {
  try {
    const userDataPath = app.getPath('userData');
    const configPath = path.join(userDataPath, 'paratext-config.json');
    
    if (fs.existsSync(configPath)) {
      const configData = fs.readFileSync(configPath, 'utf8');
      const config = JSON.parse(configData);
      return config.projectsPath;
    }
  } catch (err) {
    console.error('Error reading stored Paratext projects path:', err);
  }
  return null;
}

// Function to save the Paratext projects path
function saveProjectsPath(projectsPath) {
  try {
    const userDataPath = app.getPath('userData');
    const configPath = path.join(userDataPath, 'paratext-config.json');
    
    const configData = JSON.stringify({ projectsPath });
    fs.writeFileSync(configPath, configData, 'utf8');
    console.log(`Saved Paratext projects path: ${projectsPath}`);
  } catch (err) {
    console.error('Error saving Paratext projects path:', err);
  }
}

// Function to prompt the user for the Paratext projects path
async function promptUserForParatextPath() {
  console.log('Prompting user to select Paratext projects folder...');
  try {
    // Make sure we have a window to parent the dialog
    let parentWindow = BrowserWindow.getFocusedWindow();
    
    // If no window is focused, get the first one
    if (!parentWindow) {
      const windows = BrowserWindow.getAllWindows();
      if (windows.length > 0) {
        parentWindow = windows[0];
        console.log('Using first available window for dialog parent');
      }
    }
    
    if (parentWindow) {
      console.log(`Using window with id ${parentWindow.id} as dialog parent`);
      parentWindow.focus(); // Make sure the window has focus
    } else {
      console.log('Warning: No window available for dialog parent');
    }
    
    // Show folder selection dialog
    console.log('Opening folder selection dialog...');
    const result = await dialog.showOpenDialog(parentWindow || undefined, {
      properties: ['openDirectory'],
      title: 'Select Paratext Projects Folder',
      buttonLabel: 'Select Folder',
      message: 'Please select your Paratext Projects folder (usually "My Paratext 9 Projects")'
    });
    
    console.log('Folder selection dialog result:', result);
    if (result.canceled || !result.filePaths.length) {
      console.log('User canceled folder selection');
      return null;
    }
    
    const selectedPath = result.filePaths[0];
    console.log(`User selected path: "${selectedPath}"`);
    
    // Validate the selected path
    if (validateParatextPath(selectedPath)) {
      console.log(`Selected path is valid, setting as Paratext projects path: "${selectedPath}"`);
      PARATEXT_PROJECTS_PATH = selectedPath;
      saveProjectsPath(selectedPath);
      return selectedPath;
    } else {
      console.log(`Selected path is NOT valid: "${selectedPath}"`);
      
      // Show error dialog about missing _MapLabelerTemplates folder
      console.log('Showing missing _MapLabelerTemplates folder dialog...');
      const { response } = await dialog.showMessageBox(parentWindow || undefined, {
        type: 'error',
        title: 'Missing _MapLabelerTemplates Folder',
        message: 'The selected folder does not contain the required _MapLabelerTemplates folder.',
        detail: 'You must first install the _MapLabelerTemplates folder in your Paratext Projects directory before using this application. Please contact your administrator or refer to the installation guide.',
        buttons: ['Try Another Folder', 'Cancel']
      });
      
      console.log(`Missing folder dialog response: ${response}`);
      if (response === 0) { // Try Again
        console.log('User chose to try another folder');
        return promptUserForParatextPath();
      } else {
        console.log('User chose to cancel');
      }
    }
  } catch (err) {
    console.error('Error prompting for Paratext projects path:', err);
  }
  
  console.log('No valid Paratext projects path selected');
  return null;
}

// Function to get the current Paratext projects path, prompting if necessary
async function getParatextProjectsPath() {
  if (PARATEXT_PROJECTS_PATH && fs.existsSync(PARATEXT_PROJECTS_PATH)) {
    return PARATEXT_PROJECTS_PATH;
  }
  
  return promptUserForParatextPath();
}

// Initialize the Paratext projects path when the app is ready
app.whenReady().then(async () => {
  console.log('Application starting...');
  
  // First create the window so we have it for dialog parent
  console.log('Creating main window...');
  const mainWindow = createWindow();
  
  // Wait a moment to ensure the window is fully initialized and visible
  console.log('Waiting for window to be ready...');
  await new Promise((resolve) => {
    // If already visible, resolve immediately
    if (mainWindow.isVisible()) {
      console.log('Window is already visible');
      resolve();
    } else {
      // Otherwise wait for ready-to-show event
      console.log('Waiting for ready-to-show event...');
      mainWindow.once('ready-to-show', () => {
        console.log('Window ready-to-show event received');
        resolve();
      });
    }
  });
  
  // Additional small delay to ensure window is fully rendered
  await new Promise(resolve => setTimeout(resolve, 500));
  console.log('Window should be ready now');
  
  try {
    // Try to initialize Paratext projects path
    console.log('Starting Paratext projects path initialization...');
    const initSuccess = await initParatextProjectsPath();
    console.log(`Paratext projects path initialization result: ${initSuccess ? 'Success' : 'Failed'}`);
    console.log(`Current Paratext projects path: ${PARATEXT_PROJECTS_PATH || 'Not set'}`);
    
    // If initialization failed, show dialog
    if (!initSuccess) {
      console.log('WARNING: Failed to initialize Paratext projects path - showing dialog');
      
      try {
        console.log('Showing Paratext path configuration dialog...');
        const { response } = await dialog.showMessageBox(mainWindow, {
          type: 'warning',
          title: 'Paratext Path Configuration Issue',
          message: 'Biblical Map App could not locate a valid Paratext projects folder with the _MapLabelerTemplates subfolder.',
          detail: 'You must have the _MapLabelerTemplates folder installed in your Paratext Projects directory for this application to work properly.',
          buttons: ['Browse for Folder', 'Continue Anyway']
        });
        
        console.log(`Dialog response: ${response}`);
        
        // If user chooses to browse for folder
        if (response === 0) {
          console.log('User chose to browse for folder');
          const selectedPath = await promptUserForParatextPath();
          console.log(`User selected path: ${selectedPath || 'No path selected'}`);
          if (!selectedPath) {
            console.log('User canceled folder selection or selected an invalid folder');
            await dialog.showMessageBox(mainWindow, {
              type: 'warning',
              title: 'No Valid Path Selected',
              message: 'You chose to continue without selecting a valid Paratext projects folder.',
              detail: 'Some features of the application may not work correctly.',
              buttons: ['OK']
            });
          }
        } else {
          console.log('User chose to continue without selecting a path');
        }
      } catch (dialogErr) {
        console.error('Error showing dialog:', dialogErr);
      }
    }
  } catch (err) {
    console.error('Error during initialization:', err);
    try {
      await dialog.showMessageBox(mainWindow, {
        type: 'error',
        title: 'Initialization Error',
        message: 'An error occurred during application initialization.',
        detail: `Error details: ${err.message}`,
        buttons: ['OK']
      });
    } catch (dialogErr) {
      console.error('Error showing error dialog:', dialogErr);
    }
  }
});

initialize();

function createWindow() {
  console.log('Creating BrowserWindow...');
  const win = new BrowserWindow({
    width: 1200,
    height: 900,
    icon: path.join(__dirname, 'icon.ico'), // This sets the window icon
    webPreferences: {
      nodeIntegration: false, // more secure
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
    show: false, // Don't show until ready
  });
  
  // Show window when ready to avoid white flashing
  win.once('ready-to-show', () => {
    win.show();
    win.focus(); // Ensure the window has focus for dialogs
    console.log('Window is now visible');
  });
  
  enable(win.webContents);
  
  // Check if we're in development or production
  const isDev = process.env.NODE_ENV === 'development';
  
  if (isDev) {
    // For development: load React dev server
    console.log('Running in development mode...');
    win.loadURL('http://localhost:3000');
    // Open DevTools in development mode
    win.webContents.openDevTools();
  } else {
    // For production: load built files
    const indexPath = path.join(__dirname, 'index.html');
    console.log('Running in production mode, loading index from:', indexPath);
    
    // Enable more verbose logging for debugging
    win.webContents.on('did-start-loading', () => {
      console.log('Started loading the page');
    });
    
    win.webContents.on('did-finish-load', () => {
      console.log('Page loaded successfully');
    });
    
    win.webContents.on('did-fail-load', (event, errorCode, errorDescription) => {
      console.error('Failed to load:', errorCode, errorDescription);
    });
    
    win.webContents.on('console-message', (event, level, message, line, sourceId) => {
      console.log(`Console ${level}: ${message}`);
    });
    
    // Load the index.html file
    win.loadFile(indexPath);
  }
  
  // Handle squirrel events for Windows installer
  if (require('electron-squirrel-startup')) {
    app.quit();
  }
    return win; // Return the window object
}

function BCV(ref) {
  const bookNum = parseInt(ref.slice(0, 3), 10) - 1;
  const chapter = parseInt(ref.slice(3,  6), 10);    
  const verse = parseInt(ref.slice(6, 9), 10);
  return [bookNum, chapter, verse];
}

function bookName(bookNum, projectFolder) {
  const bookPrefixes = '01GEN,02EXO,03LEV,04NUM,05DEU,06JOS,07JDG,08RUT,091SA,102SA,111KI,122KI,131CH,142CH,15EZR,16NEH,17EST,18JOB,19PSA,20PRO,21ECC,22SNG,23ISA,24JER,25LAM,26EZK,27DAN,28HOS,29JOL,30AMO,31OBA,32JON,33MIC,34NAM,35HAB,36ZEP,37HAG,38ZEC,39MAL,41MAT,42MRK,43LUK,44JHN,45ACT,46ROM,471CO,482CO,49GAL,50EPH,51PHP,52COL,531TH,542TH,551TI,562TI,57TIT,58PHM,59HEB,60JAS,611PE,622PE,631JN,642JN,653JN,66JUD,67REV,68TOB,69JDT,70ESG,71WIS,72SIR,73BAR,74LJE,75S3Y,76SUS,77BEL,781MA,792MA,803MA,814MA,821ES,832ES,84MAN,85PS2,86ODA,87PSS,A4EZA,A55EZ,A66EZ,B2DAG,B3PS3,B42BA,B5LBA,B6JUB,B7ENO,B81MQ,B92MQ,C03MQ,C1REP,C24BA,C3LAO,A0FRT,A1BAK,A2OTH,A7INT,A8CNC,A9GLO,B0TDX,B1NDX,94XXA,95XXB,96XXC,97XXD,98XXE,99XXF';
  const bookPrefix = bookPrefixes.slice(bookNum*6, bookNum*6+5);
  const folderName = path.basename(projectFolder);
  return path.join(projectFolder, bookPrefix + folderName + '.sfm');
}

async function termsXmlToObject(xmlString) {
  try {
    // Parse XML string
    const result = await xml2js.parseStringPromise(xmlString.replace(/\r/g, ''), {
      explicitArray: false, // Avoid arrays for single elements
      mergeAttrs: true, // Merge attributes (like Id, Guess) into the object
    });

    // Transform to desired structure
    const termRenderings = result.TermRenderingsList.TermRendering;
    const output = {};

    // Handle single or multiple TermRendering elements
    const termArray = Array.isArray(termRenderings) ? termRenderings : [termRenderings];

    termArray.forEach((term) => {
      const id = term.Id;
      // Unicode normalization for Id
      const key = id.normalize('NFC');
      output[key] = {
        originalId: id,
        renderings: term.Renderings.replace(/\|\|/g, '\n'),
        isGuessed: term.Guess === 'true', // Convert string 'true'/'false' to boolean
        denials: term.Denials?.Denial
          ? Array.isArray(term.Denials.Denial)
            ? term.Denials.Denial
            : [term.Denials.Denial]
          : [],
        // Store additional elements for preservation
        _glossary: term.Glossary,
        _changes: term.Changes,
        _notes: term.Notes,
      };
    });

    return output;
  } catch (error) {
    console.error('Error parsing XML:', error);
    throw error;
  }
}

async function termsObjectToXml(obj) {
  try {
    const builder = new xml2js.Builder({
      xmldec: { version: '1.0', encoding: 'utf-8' },
      renderOpts: { pretty: true },
    });

    // Build the TermRenderingsList structure
    const xmlObj = {
      TermRenderingsList: {
        TermRendering: Object.entries(obj).map(([id, data]) => ({
          $: { Id: data.originalId ?? id, Guess: data.isGuessed.toString() }, // Attributes
          Renderings: data.renderings.replace(/\n/g, '||'), // Convert newlines to ||
          Glossary: data._glossary || {}, // Preserve empty or existing
          Changes: data._changes || {}, // Preserve empty or existing
          Notes: data._notes || {}, // Preserve empty or existing
          Denials: data.denials?.length ? { Denial: data.denials } : {}, // Handle denials array
        })),
      },
    };

    return builder.buildObject(xmlObj)
    .replace(/\/>/g, ' />') // Add original space to self-closing tags
    .replace(/\n/g, '\r\n') // Revert newlines to CRLF 
    .replace(/<Change>\s*\n\s*<UserName>([^<]*)<\/UserName>\s*\n\s*<Date>([^<]*)<\/Date>/g, '<Change UserName="$1" Date="$2">'); // Convert Change elements to attributes
  } catch (error) {
    console.error('Error building XML:', error);
    throw error;
  }
}

ipcMain.handle('load-term-renderings', async (event, projectFolder) => {
  try {
    const xmlFilePath = path.join(projectFolder, 'TermRenderings.xml');
    const xmlFilePathDemo = path.join(projectFolder, 'TermRenderings-Demo.xml');

    let xmlFilePathToUse = xmlFilePath;
    if (fs.existsSync(xmlFilePathDemo)) {
      xmlFilePathToUse = xmlFilePathDemo;
    }
    console.log('Loading term renderings from:', xmlFilePathToUse);
    // Read the XML file into a javascript object
    if (fs.existsSync(xmlFilePathToUse)) {
      const data = fs.readFileSync(xmlFilePathToUse, 'utf8');
      const obj = await termsXmlToObject(data);
      return obj;
    } else {
      console.log('no xml renderings.')
    }
  } catch (e) {
      console.log('error loading term renderings:', e);
  }
  return {};
});

ipcMain.handle('save-term-renderings', async (event, projectFolder, data) => {
  try {
    const filePath = path.join(projectFolder, 'TermRenderings-Demo.xml');
    const xmlOutput = await termsObjectToXml(data);
    fs.writeFileSync(filePath, xmlOutput, 'utf8');
    console.log('Term renderings saved successfully.');
    return { success: true };
  } catch (e) {
    return { error: e.message };
  }
});

ipcMain.handle('select-project-folder', async (event) => {
  // Get the current Paratext projects path as the default starting directory
  let defaultPath;
  try {
    defaultPath = PARATEXT_PROJECTS_PATH;
    if (!defaultPath || !fs.existsSync(defaultPath)) {
      defaultPath = undefined; // Let the dialog use its default
    }
  } catch (err) {
    console.error('Error getting default path for folder dialog:', err);
  }
  
  const result = await dialog.showOpenDialog({
    properties: ['openDirectory'],
    title: 'Select a Project Folder',
    defaultPath: defaultPath,
  });
  
  if (result.canceled || !result.filePaths.length) {
    return null;
  }
  return result.filePaths[0];
});

function getVerseText(usfmChapterText, verseNum) {
  // Regular expression to match verse markers (single or bridged, e.g., \v 12 or \v 11-14)
  const verseRegex = /\\v (\d+(?:-\d+)?)(.*?)(?=(?:\\v \d+(?:-\d+)?|$))/gs;
  
  let result = '';
  let match;

  // Iterate through all verse matches
  while ((match = verseRegex.exec(usfmChapterText)) !== null) {
    const verseRange = match[1]; // e.g., "12" or "11-14"
    const verseContent = match[2].trim(); // Content after the verse marker

    // Check if verseNum is a single number or part of a range
    if (verseRange.includes('-')) {
      // Handle bridged verses (e.g., "11-14")
      const [start, end] = verseRange.split('-').map(Number);
      if (verseNum >= start && verseNum <= end) {
        return verseContent;
      }
    } else {
      // Handle single verse (e.g., "12")
      if (parseInt(verseRange) === verseNum) {
        return verseContent;
      }
    }
  }
  // if (usfmChapterText && !result) {
    console.log('There is chapter text but verse not found:', verseNum);
  // }
  return result; // Return empty string if verse not found
}

// Helper to clean USFM verse text (remove markers, keep readable text)
function cleanUsfmText(usfmText) {  //TODO: Verify this cleans things accurately.
  // Remove footnotes, cross-references, and all \...* blocks
  usfmText = usfmText.replace(/\\f .*?\\f\*/gs, '');
  usfmText = usfmText.replace(/\\x .*?\\x\*/gs, '');
  usfmText = usfmText.replace(/\\ft .*?\\ft\*/gs, '');
  usfmText = usfmText.replace(/\\add .*?\\add\*/gs, '');
  // Remove section headings, parallel passage refs, etc.
  usfmText = usfmText.replace(/\\s[0-9]? .*/g, '');
  usfmText = usfmText.replace(/\\r .*/g, '');
  usfmText = usfmText.replace(/\\p/g, '');
  usfmText = usfmText.replace(/\\q[0-9]?/g, '');
  // Remove formatting markers but keep their content
  usfmText = usfmText.replace(/\\[a-zA-Z0-9]+\*/g, '');
  usfmText = usfmText.replace(/\\[a-zA-Z0-9]+/g, '');
  // Remove word-level markup: \w ...|...
  usfmText = usfmText.replace(/\\w ([^|]+)\|[^\\]+\\w\*/g, '$1');
  // Remove extra whitespace
  usfmText = usfmText.replace(/\s+/g, ' ').trim();
  return usfmText;
}

ipcMain.handle('get-filtered-verses', async (event, projectFolder, curRefs) => {
  try {
    const requestedVerses = {};
    const chapterVersePerBook = {};
    // For each reference, push chapter and verse onto the array for that book
    curRefs.forEach(ref => {
      const [bookNum, chapter, verse] = BCV(ref);
      const bName = bookName(bookNum, projectFolder);
      if (!chapterVersePerBook[bName]) {
        chapterVersePerBook[bName] = [];
      }
      chapterVersePerBook[bName].push([chapter, verse, ref]);
    });
    // console.log('chapterVersePerBook:', chapterVersePerBook);

    // For each key in chapterVersePerBook, read the SFM file and add the verses to requestedVerses
    for (const [bName, refArray] of Object.entries(chapterVersePerBook)) {
      const filePath = bName;
      if (fs.existsSync(filePath)) {
        // console.log(`Processing book: ${bName}`);
        const usfmText = fs.readFileSync(filePath, 'utf8');
        const chapters = {};
        usfmText.split(/(\\c \d+)/).slice(1).forEach((content, i, arr) => {
          if (i % 2 === 0) { // Chapter marker
            const chapterNum = parseInt(content.match(/\d+/)[0]);
            chapters[chapterNum] = arr[i + 1] || '';
          }
        });
        // console.log(`Found ${Object.keys(chapters).length} chapters in book: ${bName}`, refArray);
        for (const [chapter, verse, ref] of refArray) {
          // console.log(`Processing ref: ${ref} (Chapter: ${chapter}, Verse: ${verse})`);
          if (chapters[chapter]) {
            const verseText = getVerseText(chapters[chapter], verse);
            // console.log(`Found verse text for ${ref}:`, verseText);
            if (verseText) {
              const cleanedText = cleanUsfmText(verseText);
              requestedVerses[ref] = cleanedText;
              // console.log(`Added verse ${verse} from chapter ${chapter} of book ${bName}:`, cleanedText);
            } else {
              console.warn(`Verse ${verse} not found in chapter ${chapter} of book ${bName}`);
            }
          } else {
            console.warn(`Chapter ${chapter} not found in book ${bName}`);
          }
        }
          // const filePath = path.join(projectFolder, 'all_verses.json');
          // const allVerses = JSON.parse(fs.readFileSync(filePath, 'utf8'));
          // const filtered = Object.fromEntries(
          //   curRefs.filter(ref => allVerses.hasOwnProperty(ref)).map(ref => [ref, allVerses[ref]])
          // );
          // return filtered;
        } else {
        console.log(`File not found: ${filePath}`);
      }
    }
    return requestedVerses;
  } catch (e) {
    console.log('Error getting filtered verses:', e);
    return { error: e.message };
  }
});

// Add an IPC handler to check the _MapLabelerTemplates folder
ipcMain.handle('check-map-templates-folder', async (event) => {
  try {
    console.log('Renderer asked to check for _MapLabelerTemplates folder');
    let projectsPath = await getParatextProjectsPath();
    
    if (!projectsPath) {
      console.log('No Paratext projects path configured - will show dialog from renderer');
      return { 
        exists: false, 
        message: 'Paratext projects path not found. Please select it first.' 
      };
    }
    
    console.log(`Checking for _MapLabelerTemplates in: "${projectsPath}"`);
    const templatesPath = path.join(projectsPath, '_MapLabelerTemplates');
    const exists = fs.existsSync(templatesPath);
      
    if (exists) {
      console.log(`_MapLabelerTemplates found at: "${templatesPath}"`);
      return { 
        exists: true, 
        path: templatesPath 
      };
    } else {
      console.log(`_MapLabelerTemplates NOT found at: "${templatesPath}"`);
      return { 
        exists: false, 
        error: 'Missing _MapLabelerTemplates folder',
        message: 'The _MapLabelerTemplates folder is not installed in your Paratext Projects directory. Please install it before using this application.'
      };
    }
  } catch (e) {
    console.error('Error checking _MapLabelerTemplates folder:', e);
    return { 
      exists: false, 
      error: e.message 
    };
  }
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});
